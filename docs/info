https://neerc.ifmo.ru/wiki/index.php?title=2-3_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE


2-3 дерево

Пример 2-3 дерева
2-3 дерево (англ. 2-3 tree) — структура данных, представляющая собой сбалансированное дерево поиска, такое что из каждого узла может выходить две или три ветви и глубина всех листьев одинакова. Является частным случаем B+ дерева.
Содержание
1	Свойства
2	Операции
2.1	Поиск
2.2	Вставка элемента
2.3	Удаление элемента
2.4	Следующий и предыдущий
2.5	Нахождение m следующих элементов
3	См. также
4	Источники информации
Свойства
2-3 дерево — сбалансированное дерево поиска, обладающее следующими свойствами:

нелистовые вершины имеют либо 2
, либо 3
 сына,
нелистовая вершина, имеющая двух сыновей, хранит максимум левого поддерева. Нелистовая вершина, имеющая трех сыновей, хранит два значения. Первое значение хранит максимум левого поддерева, второе максимум центрального поддерева,
сыновья упорядочены по значению максимума поддерева сына,
все листья лежат на одной глубине,
высота 2-3 дерева O(logn)
, где n
 — количество элементов в дереве.
Операции
Введем следующие обозначения:

root
 — корень 2-3 дерева.
Каждый узел дерева обладает полями:

parent
 — родитель узла,
sons
 — сыновья узла,
keys
 — ключи узла,
length
 — количество сыновей.
Поиск
x
 — искомое значение,
t
 — текущая вершина в дереве.
Изначально t=root
. Будем просматривать ключи в узлах, пока узел не является листом. Рассмотрим два случая:

у текущей вершины два сына. Если её значение меньше x
, то t=t.sons[1]
, иначе t=t.sons[0]
.
у текущей вершины три сына. Если второе значение меньше x
, то t=t.sons[2]
. Если первое значение меньше x
, то t=t.sons[1]
, иначе t=t.sons[0]
.
T search(T x):
  Node t = root
  while (t не является листом)
    if (t.length == 2)
      if (t.keys[0] < x)
        t = t.sons[1]
      else 
        t = t.sons[0]
    else if (t.keys[1] < x)
      t = t.sons[2]
    else if (t.keys[0] < x)
      t = t.sons[1]
    else 
      t = t.sons[0]
  return t.keys[0]

Поиск элемента 19, оранжевые стрелки обозначают путь по дереву при поиске
Вставка элемента
x
 — добавляемое значение,
t
 — текущая вершина в дереве. Изначально t=root
.
Если корня не существует — дерево пустое, то новый элемент и будет корнем (одновременно и листом). Иначе поступим следующим образом:

Найдем сперва, где бы находился элемент, применив search(x)
. Далее проверим есть ли у этого узла родитель, если его нет, то в дереве всего один элемент — лист. Возьмем этот лист и новый узел, и создадим для них родителя, лист и новый узел расположим в порядке возрастания.

Если родитель существует, то подвесим к нему ещё одного сына. Если сыновей стало 4
, то разделим родителя на два узла, и повторим разделение теперь для его родителя, ведь у него тоже могло быть уже 3
 сына, а мы разделили и у него стало на 1
 сына больше. (перед разделением обновим ключи).

function splitParent(Node t):
 if (t.length > 3) 
   Node a = Node(sons = {t.sons[2], t.sons[3]}, keys = {t.keys[2]}, parent = t.parent, length = 2)
   t.sons[2].parent = a
   t.sons[3].parent = a
   t.length = 2
   t.sons[2] = null
   t.sons[3] = null
   if (t.parent != null)
     t.parent[t.length] = a
     t.length++
     сортируем сыновей у t.parent
     splitParent(t.parent)
   else                   // мы расщепили корень, надо подвесить его к общему родителю, который будет новым корнем
    Node t = root
    root.sons[0] = t
    root.sons[1] = a
    t.parent = root
    a.parent = root
    root.length = 2
    сортируем сыновей у root
Если сыновей стало 3
, то ничего не делаем. Далее необходимо восстановить ключи на пути от новой вершины до корня:

function updateKeys(Node t): 
  Node a = t.parent
  while (a != null)
   for i = 0 .. a.length - 1
     a.keys[i] = max(a.sons[i]) // max — возвращает максимальное значение в поддереве.
   a = a.parent                 // Примечание: max легко находить, если хранить максимум 
                                // правого поддерева в каждом узле — это значение и будет max(a.sons[i])
updateKeys
 необходимо запускать от нового узла. Добавление элемента:

function insert(T x):
  Node n = Node(x)
  if (root == null) 
   root = n
   return
  Node a = searchNode(x)     
  if (a.parent == null) 
    Node t = root
    root.sons[0] = t
    root.sons[1] = n
    t.parent = root
    n.parent = root
    root.length = 2
    сортируем сыновей у root
  else 
    Node p = a.parent
    p.sons[p.length] = n
    p.length++
    n.parent = p
    сортируем сыновей у p
    updateKeys(n) 
    split(n)
  updateKeys(n) 
Так как мы спускаемся один раз, и поднимаемся вверх при расщеплении родителей не более одного раза, то insert
 работает за O(logn)
.

Примеры добавления:


Добавление элемента с ключом 6
Удаление элемента
x
 — значение удаляемого узла,
t
 — текущий узел,
b
 — брат t
,
p
 — отец t
,
np
 — соседний брат p
,
gp
 — отец p
.
Пусть изначально t=searchNode(x)
 — узел, где находится x
.

Если у t
 не существует родителя, то это корень (одновременно и единственный элемент в дереве). Удалим его.

Если p
 существует, и у него строго больше 2
 сыновей, то просто удалим t
, а у p
 уменьшим количество детей.

Если у родителя t
 два сына, рассмотрим возможные случаи (сперва везде удаляем t
):

np
 не существует, тогда мы удаляем одного из сыновей корня, следовательно, другой сын становится новым корнем,
у gp
 оказалось 2
 сына, у np
 оказалось 2
 сына. Подвесим b
 к np
 и удалим p
. Так как у gp
 — родителя p
, оказалось тоже два сына, повторяем для p
 такие же рассуждения,
у gp
 оказалось 2
 или 3
 сына, у np
 оказалось 3
 сына. Просто заберем ближайшего к нам сына у np
 и прицепим его к p
. Восстановим порядок в сыновьях p
. Теперь у p
 оказалось снова два сына и все узлы 2-3 дерева корректны,
у gp
 оказалось 3
 сына, у np
 оказалось 2
 сына. Подвесим b
 к np
 и удалим p
, а у gp
 уменьшим количество детей. Так как у np
 оказалось три сына, а у gp
 все ещё больше одного сына, то все узлы 2-3 дерева корректны.

Обобщим алгоритм при удалении когда у родителя t
 два сына:

Если np
 не существует, то оказывается, что мы сейчас удаляем какого-то из сыновей корня (для определенности далее левого, с правым аналогично). Тогда теперь правый сын становится корнем. На этом удаление заканчивается.
Если np
 существует, то удалим t
, а его брата (b
) перецепим к np
. Теперь у np
 могло оказаться 4
 сына, поэтому повторим аналогичные действия из insert
: вызовем updateKeys(b)
 и splitParent(np)
. Теперь рекурсивно удалим p
.
В результате мы получаем корректное по структуре 2-3 дерево, но у нас есть нарушение в ключах в узлах, исправим их с помощью updateKeys()
, запустившись от b
.


Удаление элемента с ключом 2
Следующий и предыдущий
x
 — поисковый параметр,
t
 — текущий узел.
В силу того, что наши узлы отсортированы по максимуму в поддереве, то следующий объект — это соседний лист справа. Попасть туда можно следующим образом: будем подниматься вверх, пока у нас не появится первой возможности свернуть направо вниз. Как только мы свернули направо вниз, будем идти всегда влево. Таким образом, мы окажемся в соседнем листе. Если мы не смогли ни разу свернуть направо вниз, и пришли в корень, то следующего объекта не существует. Случай с предыдущим симметричен.

 T next(T x):
   Node t = searchNode(x)
   if (t.keys[0] > x)  //x не было в дереве, и мы нашли следующий сразу
     return t.keys[0]
   while (t != null)
     t = t.parent
     if (можно свернуть направо вниз)
      в t помещаем вершину, в которую свернули
      while (пока t — не лист)
       t = t.sons[0]
     return t
   return t.keys[0]
    

Путь при поиске следующего элемента после 2
Нахождение m следующих элементов
B+ деревья, поддерживают операцию find
, которая позволяет находить m следующих элементов. Наивная реализация выглядит следующим образом: будем вызывать m
 раз поиск следующего элемента, такое решение работает за O(mlogn)
. Но 2-3 деревья, позволяют находить m следующих элементов за O(m+logn)
, что значительно ускоряет поиск при больших m
. По построению, все листья у нас отсортированы в порядке возрастания, воспользуемся этим для нахождения m элементов. Нам необходимо связать листья, для этого модифицируем insert
 и delete
. Добавим к узлам следующие поля:

right
 — указывает на правый лист,
left
 — указывает на левый лист.
Пусть t
 — добавленный узел. Изменим insert
 следующим образом: в самом конце, после того как мы уже обновили все ключи, найдем next(t)
 и запишем ссылку на него в t.right
. Аналогично с левым.

Пусть t
 — удаляемый узел. Изменим delete
 следующим образом: в самом начале, до удаления t
, найдем следующий next
 и запишем в next.left
 правый лист относительно t
. С левым поступим аналогично.

В итоге, мы имеем двусвязный список в листьях, и чтобы нам вывести m
 элементов, нам достаточно один раз найти нужный элемент и пробежаться вправо на m
 элементов.

https://fkti5301.github.io/exam_tickets_aisd_2017_kolinko/tickets/13.html


2-3 дерево

Пример 2-3 дерева
2-3 дерево (англ. 2-3 tree) — структура данных, представляющая собой сбалансированное дерево поиска, такое что из каждого узла может выходить две или три ветви и глубина всех листьев одинакова. Является частным случаем B+ дерева.
Содержание
1	Свойства
2	Операции
2.1	Поиск
2.2	Вставка элемента
2.3	Удаление элемента
2.4	Следующий и предыдущий
2.5	Нахождение m следующих элементов
3	См. также
4	Источники информации
Свойства
2-3 дерево — сбалансированное дерево поиска, обладающее следующими свойствами:

нелистовые вершины имеют либо 2
, либо 3
 сына,
нелистовая вершина, имеющая двух сыновей, хранит максимум левого поддерева. Нелистовая вершина, имеющая трех сыновей, хранит два значения. Первое значение хранит максимум левого поддерева, второе максимум центрального поддерева,
сыновья упорядочены по значению максимума поддерева сына,
все листья лежат на одной глубине,
высота 2-3 дерева O(logn)
, где n
 — количество элементов в дереве.
Операции
Введем следующие обозначения:

root
 — корень 2-3 дерева.
Каждый узел дерева обладает полями:

parent
 — родитель узла,
sons
 — сыновья узла,
keys
 — ключи узла,
length
 — количество сыновей.
Поиск
x
 — искомое значение,
t
 — текущая вершина в дереве.
Изначально t=root
. Будем просматривать ключи в узлах, пока узел не является листом. Рассмотрим два случая:

у текущей вершины два сына. Если её значение меньше x
, то t=t.sons[1]
, иначе t=t.sons[0]
.
у текущей вершины три сына. Если второе значение меньше x
, то t=t.sons[2]
. Если первое значение меньше x
, то t=t.sons[1]
, иначе t=t.sons[0]
.
T search(T x):
  Node t = root
  while (t не является листом)
    if (t.length == 2)
      if (t.keys[0] < x)
        t = t.sons[1]
      else 
        t = t.sons[0]
    else if (t.keys[1] < x)
      t = t.sons[2]
    else if (t.keys[0] < x)
      t = t.sons[1]
    else 
      t = t.sons[0]
  return t.keys[0]

Поиск элемента 19, оранжевые стрелки обозначают путь по дереву при поиске
Вставка элемента
x
 — добавляемое значение,
t
 — текущая вершина в дереве. Изначально t=root
.
Если корня не существует — дерево пустое, то новый элемент и будет корнем (одновременно и листом). Иначе поступим следующим образом:

Найдем сперва, где бы находился элемент, применив search(x)
. Далее проверим есть ли у этого узла родитель, если его нет, то в дереве всего один элемент — лист. Возьмем этот лист и новый узел, и создадим для них родителя, лист и новый узел расположим в порядке возрастания.

Если родитель существует, то подвесим к нему ещё одного сына. Если сыновей стало 4
, то разделим родителя на два узла, и повторим разделение теперь для его родителя, ведь у него тоже могло быть уже 3
 сына, а мы разделили и у него стало на 1
 сына больше. (перед разделением обновим ключи).

function splitParent(Node t):
 if (t.length > 3) 
   Node a = Node(sons = {t.sons[2], t.sons[3]}, keys = {t.keys[2]}, parent = t.parent, length = 2)
   t.sons[2].parent = a
   t.sons[3].parent = a
   t.length = 2
   t.sons[2] = null
   t.sons[3] = null
   if (t.parent != null)
     t.parent[t.length] = a
     t.length++
     сортируем сыновей у t.parent
     splitParent(t.parent)
   else                   // мы расщепили корень, надо подвесить его к общему родителю, который будет новым корнем
    Node t = root
    root.sons[0] = t
    root.sons[1] = a
    t.parent = root
    a.parent = root
    root.length = 2
    сортируем сыновей у root
Если сыновей стало 3
, то ничего не делаем. Далее необходимо восстановить ключи на пути от новой вершины до корня:

function updateKeys(Node t): 
  Node a = t.parent
  while (a != null)
   for i = 0 .. a.length - 1
     a.keys[i] = max(a.sons[i]) // max — возвращает максимальное значение в поддереве.
   a = a.parent                 // Примечание: max легко находить, если хранить максимум 
                                // правого поддерева в каждом узле — это значение и будет max(a.sons[i])
updateKeys
 необходимо запускать от нового узла. Добавление элемента:

function insert(T x):
  Node n = Node(x)
  if (root == null) 
   root = n
   return
  Node a = searchNode(x)     
  if (a.parent == null) 
    Node t = root
    root.sons[0] = t
    root.sons[1] = n
    t.parent = root
    n.parent = root
    root.length = 2
    сортируем сыновей у root
  else 
    Node p = a.parent
    p.sons[p.length] = n
    p.length++
    n.parent = p
    сортируем сыновей у p
    updateKeys(n) 
    split(n)
  updateKeys(n) 
Так как мы спускаемся один раз, и поднимаемся вверх при расщеплении родителей не более одного раза, то insert
 работает за O(logn)
.

Примеры добавления:


Добавление элемента с ключом 6
Удаление элемента
x
 — значение удаляемого узла,
t
 — текущий узел,
b
 — брат t
,
p
 — отец t
,
np
 — соседний брат p
,
gp
 — отец p
.
Пусть изначально t=searchNode(x)
 — узел, где находится x
.

Если у t
 не существует родителя, то это корень (одновременно и единственный элемент в дереве). Удалим его.

Если p
 существует, и у него строго больше 2
 сыновей, то просто удалим t
, а у p
 уменьшим количество детей.

Если у родителя t
 два сына, рассмотрим возможные случаи (сперва везде удаляем t
):

np
 не существует, тогда мы удаляем одного из сыновей корня, следовательно, другой сын становится новым корнем,
у gp
 оказалось 2
 сына, у np
 оказалось 2
 сына. Подвесим b
 к np
 и удалим p
. Так как у gp
 — родителя p
, оказалось тоже два сына, повторяем для p
 такие же рассуждения,
у gp
 оказалось 2
 или 3
 сына, у np
 оказалось 3
 сына. Просто заберем ближайшего к нам сына у np
 и прицепим его к p
. Восстановим порядок в сыновьях p
. Теперь у p
 оказалось снова два сына и все узлы 2-3 дерева корректны,
у gp
 оказалось 3
 сына, у np
 оказалось 2
 сына. Подвесим b
 к np
 и удалим p
, а у gp
 уменьшим количество детей. Так как у np
 оказалось три сына, а у gp
 все ещё больше одного сына, то все узлы 2-3 дерева корректны.

Обобщим алгоритм при удалении когда у родителя t
 два сына:

Если np
 не существует, то оказывается, что мы сейчас удаляем какого-то из сыновей корня (для определенности далее левого, с правым аналогично). Тогда теперь правый сын становится корнем. На этом удаление заканчивается.
Если np
 существует, то удалим t
, а его брата (b
) перецепим к np
. Теперь у np
 могло оказаться 4
 сына, поэтому повторим аналогичные действия из insert
: вызовем updateKeys(b)
 и splitParent(np)
. Теперь рекурсивно удалим p
.
В результате мы получаем корректное по структуре 2-3 дерево, но у нас есть нарушение в ключах в узлах, исправим их с помощью updateKeys()
, запустившись от b
.


Удаление элемента с ключом 2
Следующий и предыдущий
x
 — поисковый параметр,
t
 — текущий узел.
В силу того, что наши узлы отсортированы по максимуму в поддереве, то следующий объект — это соседний лист справа. Попасть туда можно следующим образом: будем подниматься вверх, пока у нас не появится первой возможности свернуть направо вниз. Как только мы свернули направо вниз, будем идти всегда влево. Таким образом, мы окажемся в соседнем листе. Если мы не смогли ни разу свернуть направо вниз, и пришли в корень, то следующего объекта не существует. Случай с предыдущим симметричен.

 T next(T x):
   Node t = searchNode(x)
   if (t.keys[0] > x)  //x не было в дереве, и мы нашли следующий сразу
     return t.keys[0]
   while (t != null)
     t = t.parent
     if (можно свернуть направо вниз)
      в t помещаем вершину, в которую свернули
      while (пока t — не лист)
       t = t.sons[0]
     return t
   return t.keys[0]
    

Путь при поиске следующего элемента после 2
Нахождение m следующих элементов
B+ деревья, поддерживают операцию find
, которая позволяет находить m следующих элементов. Наивная реализация выглядит следующим образом: будем вызывать m
 раз поиск следующего элемента, такое решение работает за O(mlogn)
. Но 2-3 деревья, позволяют находить m следующих элементов за O(m+logn)
, что значительно ускоряет поиск при больших m
. По построению, все листья у нас отсортированы в порядке возрастания, воспользуемся этим для нахождения m элементов. Нам необходимо связать листья, для этого модифицируем insert
 и delete
. Добавим к узлам следующие поля:

right
 — указывает на правый лист,
left
 — указывает на левый лист.
Пусть t
 — добавленный узел. Изменим insert
 следующим образом: в самом конце, после того как мы уже обновили все ключи, найдем next(t)
 и запишем ссылку на него в t.right
. Аналогично с левым.

Пусть t
 — удаляемый узел. Изменим delete
 следующим образом: в самом начале, до удаления t
, найдем следующий next
 и запишем в next.left
 правый лист относительно t
. С левым поступим аналогично.

В итоге, мы имеем двусвязный список в листьях, и чтобы нам вывести m
 элементов, нам достаточно один раз найти нужный элемент и пробежаться вправо на m
 элементов.

https://github.com/swapnil0399/2-3-Trees/blob/master/TwoThreeTree.java


Дэвид Мауро
Функция хеширования для координат X, Y, Z
изображение
Сегодня у меня была интересная математическая задача. Мне нужно было получить детерминированное число из трех упорядоченных чисел. В частности, я пытался получить случайное начальное число на основе координат x, y, z. Начальное число всегда будет одинаковым в зависимости от местоположения, и столкновения будут происходить только при очень большом удалении от начала координат (в идеале как можно дальше). Я мог бы сделать что-то простое, например, объединить строковые формы беззнаковых целых чисел, но тогда столкновения будут происходить раньше. Я нашел эту действительно интересную  функцию сопряжения  Мэтью Шудзика (через  StackOverflow ), которая назначает числа вдоль краев квадрата вместо традиционного метода Кантора, назначающего по диагонали. Вот визуальное сравнение:

Сочетание Кантора:

изображение

против  Шудзика Соперничество:

изображение


Это хорошо, потому что вы могли бы, например, втиснуть два 16-битных целых числа в одно 32-битное целое число без коллизий. Вычисления, используемые в функции Шудзика, также менее интенсивны, чем у Кантора.

Проблема в том, что эта функция предназначена только для пары xy, а у меня есть координаты x, y, z, которые я хотел бы использовать. Я хотел бы аналогичным образом подсчитывать вдоль ребер кубов. В идеале вывод должен выглядеть так:

fn(0, 0, 0) = 0
fn(1, 0, 0) = 1
fn(0, 1, 0) = 2
fn(1, 1, 0) = 3
fn(0, 0, 1) = 4
и т. д.

После долгих записей в блокноте я придумал такую ​​формулу:

функция(x, y, z) {
    макс = МАКС(x, y, z)
    хэш = макс^3 + (2 * макс * z) + z
    если (макс == z)
        хэш += МАКС(x, y)^2
    если (y >= x)
        хэш += x + y
    иначе
        хэш += y
    вернуть хэш
}

Эта функция сопряжения работает только с положительными числами, но если мы хотим иметь возможность использовать отрицательные координаты, мы можем просто добавить это в начало нашей функции:

x = если x >= 0, то 2 * x, иначе -2 * x - 1
y = если y >= 0, то 2 * y, иначе -2 * y - 1
z = если z >= 0, то 2 * z, иначе -2 * z - 1

Итак, теперь мы можем создать детерминированное начальное число из координат x, y, z, оставляя как можно больше места до возникновения столкновений.

4
программированиематематика18 февраля 2014 г.

https://dmauro.com/post/77011214305/a-hashing-function-for-x-y-z-coordinates

http://szudzik.com/ElegantPairing.pdf



Например, предположим, что ключи поиска имеют тип USPhoneNumber.java , который имеет три целочисленных поля area (3-значный код города), exch (3-значный обмен) и ext (4-значный добавочный номер). В этом случае мы можем вычислить число
int хэш = (((площадь * R + exch) % M) * R + ext) % M; 



thumb
См. также
B-дерево
Splay-дерево
АВЛ-дерево
Декартово дерево
Красно-черное дерево
Источники информации
is.ifmo.ru — Визуализатор 2-3 дерева
rain.ifmo.ru — Визуализатор 2-3 дерева
Википедия — 2-3 дерево
Д. Кнут «Искусство программирования. Сортировка и поиск» — стр. 508-509
Категории: Дискретная математика и алгоритмыСтруктуры данныхДеревья поиска
Навигация
Создать учётную записьВойтиСтатьяОбсуждениеЧитатьПросмотр вики-текстаИсторияПоиск
Искать в Викиконспекты
Заглавная страница
Свежие правки
Случайная статья
Справка
Инструменты
Ссылки сюда
Связанные правки
Спецстраницы
Версия для печати
Постоянная ссылка
Сведения о странице
Эта страница последний раз была отредактирована 4 сентября 2022 в 19:39.
Политика конфиденциальностиО ВикиконспектыОтказ от ответственностиМобильная версияPowered by MediaWiki
